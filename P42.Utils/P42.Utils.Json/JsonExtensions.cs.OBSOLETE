using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.Serialization;
using System.Numerics;
using System.Text.Json;
using P42.Serilog.QuickLog;

namespace P42.Utils;

/// <summary>
/// Extensions for serializing/deserializing JSON
/// </summary>
public static class JsonExtensions
{
    /// <summary>
    /// Is the object type a primitive, an enum, a string, a decimal, or a DateTime?
    /// </summary>
    /// <param name="type"></param>
    /// <returns></returns>
    public static bool IsSimple(this Type type)
    {
        var info = type.GetTypeInfo();
        return info.IsPrimitive || info.IsEnum || type == typeof(string) || type == typeof(decimal) || type == typeof(DateTime);
    }

    #region Reading / Parsing
    /// <summary>
    /// Deserialize a T, using properties in Utf8JsonReader
    /// </summary>
    /// <param name="reader">Utf8JsonReader</param>
    /// <typeparam name="T">IJsonReadable</typeparam>
    /// <returns>default if JsonTokenType is null</returns>
    public static T? Instantiate<T>(this Utf8JsonReader reader) where T : IJsonReadable, new()
    {
        if (reader.TokenType == JsonTokenType.None)
            reader.Read();

        if (reader.TokenType == JsonTokenType.Null)
            return default;

        var result = new T();
        result.PropertiesFrom(reader);
        return result;
    }
    
    /// <summary>
    /// Deserialize a list of T
    /// </summary>
    /// <param name="reader">Utf8JsonReader</param>
    /// <typeparam name="T">IJsonReadable</typeparam>
    /// <returns>null if JsonTokenType is null</returns>
    /// <exception cref="InvalidDataContractException"></exception>
    public static List<T>? ReadIJsonReadableList<T>(this Utf8JsonReader reader) where T : IJsonReadable, new()
    {
        var result = new List<T>();
        reader.Read();

        if (reader.TokenType == JsonTokenType.Null)
            return null;

        if (reader.TokenType != JsonTokenType.StartArray)
            throw new InvalidDataContractException("For the time being, all lists are assumed to be within square brackets");

        reader.Read();
        while (reader.TokenType != JsonTokenType.EndArray)
        {
            var value = new T();
            value.PropertiesFrom(reader);
            result.Add(value);
            reader.Read();
        }
        return result;
    }

    /// <summary>
    /// Deserialize list of JsonExtensions.IsSimple() items
    /// </summary>
    /// <param name="reader">Utf8JsonReader</param>
    /// <typeparam name="T">Where IsSimple() returns true</typeparam>
    /// <returns>null if JsonTokenType is null</returns>
    /// <exception cref="InvalidDataContractException"></exception>
    public static List<T>? ReadSimpleList<T>(this Utf8JsonReader reader)
    {
        var result = new List<T>();
        reader.Read();

        if (reader.TokenType == JsonTokenType.Null)
            return null;

        if (reader.TokenType != JsonTokenType.StartArray)
            throw new InvalidDataContractException("For the time being, all lists are assumed to be within square brackets");

        reader.Read();
        while (reader.TokenType != JsonTokenType.EndArray)
        {
            var value = reader.ParsePrimitive<T>();
            result.Add(value);
            reader.Read();
        }
        return result;
    }

    /*
    public static List<T> ReadJsonList<T>(this Utf8JsonReader reader)
    {
        bool isIJsonReadable = typeof(T).IsIJsonReadable();
        if (!typeof(T).IsSimple())
            throw new InvalidDataContractException("ParseListProperty only works with IJsonReadable or IsSimple types");
        bool isInt = typeof(T) == typeof(int);
        bool isEnum = typeof(T).GetTypeInfo().IsEnum;
        var result = new List<T>();
        T value;
        reader.Read();
        if (reader.TokenType != JsonTokenType.StartArray)
            throw new InvalidDataContractException("For the time being, all lists are assumed to be within square brackets");
        reader.Read();
        while (reader.TokenType != JsonTokenType.EndArray)
        {
            if (isIJsonReadable)
            {
                value = Activator.CreateInstance<T>();
                ((IJsonReadable)value).ValueFrom(reader);
            }
            else if (isInt)
                value = (T)(object)Convert.ToInt32(reader.Value);
            else if (isEnum)
                value = reader.ReadEnum<T>();
            else
                value = (T)reader.Value;
            result.Add(value);
            reader.Read();
        }
        return result;
    }
    */

    /// <summary>
    /// Read string from Utf8JsonReader
    /// </summary>
    /// <param name="reader"></param>
    /// <returns>string</returns>
    public static string? ReadString(this Utf8JsonReader reader)
    {
        reader.Read();
        return reader.ParseString();
    }

    /// <summary>
    /// casts the current reader value as a string
    /// </summary>
    /// <param name="reader"></param>
    /// <returns>null if not string</returns>
    public static string? ParseString(this Utf8JsonReader reader)
         => reader.TokenType == JsonTokenType.String
                ? reader.GetString()
                : null;
    
    /// <summary>
    /// Read int from Utf8JsonReader
    /// </summary>
    /// <param name="reader"></param>
    /// <returns></returns>
    public static int ReadInt(this Utf8JsonReader reader)
    {
        reader.Read();
        return reader.ParseInt();
    }

    /// <summary>
    /// Casts the current reader value as int
    /// </summary>
    /// <param name="reader"></param>
    /// <returns>0 if reader.Value cannot be cast to int</returns>
    public static int ParseInt(this Utf8JsonReader reader)
        => (int)ParseLong(reader);
    
    /// <summary>
    /// Read long from Utf8JsonReader
    /// </summary>
    /// <param name="reader"></param>
    /// <returns></returns>
    public static long ReadLong(this Utf8JsonReader reader)
    {
        reader.Read();
        return reader.ParseLong();
    }

    /// <summary>
    /// Casts current value to long
    /// </summary>
    /// <param name="reader"></param>
    /// <returns>0 if reader.Value cannot be cast to long</returns>
    public static long ParseLong(this Utf8JsonReader reader)
        => reader.TokenType == JsonTokenType.Number
            ? reader.GetInt64()
            : 0;
    

    /// <summary>
    /// Read bool from Utf8JsonReader
    /// </summary>
    /// <param name="reader"></param>
    /// <returns></returns>
    public static bool ReadBool(this Utf8JsonReader reader)
    {
        reader.Read();
        return reader.ParseBool();
    }

    /// <summary>
    /// Casts current value to bool
    /// </summary>
    /// <param name="reader"></param>
    /// <returns>false if reader.TokenType is not Boolean</returns>
    public static bool ParseBool(this Utf8JsonReader reader)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.True:
                return true;
            case JsonTokenType.False:
            case JsonTokenType.Null:
                return false;
            case JsonTokenType.String:
            {
                var str = (reader.GetString() ?? string.Empty).Trim();
                if (string.IsNullOrWhiteSpace(str))
                    return false;
            
                return !str.Equals("false", StringComparison.InvariantCultureIgnoreCase);
            }
            case JsonTokenType.Number when reader.TryGetDecimal(out var dValue):
                return dValue != 0;
            case JsonTokenType.Number:
                return false;
            default:
                throw new InvalidDataContractException("Unexpected JsonTokenType: " + reader.TokenType);
        }
    }


    /// <summary>
    /// Read double from Utf8JsonReader
    /// </summary>
    /// <param name="reader"></param>
    /// <returns></returns>
    public static double ReadDouble(this Utf8JsonReader reader)
    {
        reader.Read();
        return reader.ParseDouble();
    }


    /// <summary>
    /// Casts current value to double
    /// </summary>
    /// <param name="reader"></param>
    /// <returns></returns>
    /// <exception cref="InvalidDataContractException"></exception>
    public static double ParseDouble(this Utf8JsonReader reader)
    {
        double result;
        switch (reader.TokenType)
        {
            case JsonTokenType.True:
                return 1;
            case JsonTokenType.False:
            case JsonTokenType.Null:
                return 0;
            case JsonTokenType.Number:
                if (reader.TryGetDouble(out result))
                    return result;
                return 0;
            case JsonTokenType.String:
                if (reader.GetString() is not { } stringVal || string.IsNullOrWhiteSpace(stringVal))
                    return 0;
                if (!double.TryParse(stringVal, out var doubleVal))
                    throw new InvalidDataContractException($"Could not parse what JSON is a string [{stringVal}] to a double.");
                result = doubleVal;
                break;
            default:
                throw new InvalidDataContractException(
                    $"Found JSON invalid value token of type [{reader.TokenType}]");
        }
        return result;
    }

    /// <summary>
    /// Read double? from Utf8JsonReader
    /// </summary>
    /// <param name="reader"></param>
    /// <returns></returns>
    public static double? ReadNullableDouble(this Utf8JsonReader reader)
    {
        reader.Read();
        return reader.ParseNullableDouble();
    }

    /// <summary>
    /// Casts reader.Value to double or returns null
    /// </summary>
    /// <param name="reader"></param>
    /// <returns>null if reader.Value cannot be cast to double</returns>
    public static double? ParseNullableDouble(this Utf8JsonReader reader)
    {
        if (reader.TokenType == JsonTokenType.Null)
            return null;
        try
        {
            return ParseDouble(reader);
        }
        catch (Exception)
        {
            return null;
        }
    }

    /// <summary>
    /// Read DateTime from Utf8JsonReader
    /// </summary>
    /// <param name="reader"></param>
    /// <returns></returns>
    /// <exception cref="InvalidDataContractException"></exception>
    public static DateTime ReadDateTime(this Utf8JsonReader reader)
    {
        reader.Read();
        return ParseDateTime(reader);
    }

    /// <summary>
    /// Casts reader.Value to DateTime
    /// </summary>
    /// <param name="reader"></param>
    /// <returns></returns>
    /// <exception cref="InvalidDataContractException"></exception>
    public static DateTime ParseDateTime(this Utf8JsonReader reader)
    {
        var str = reader.GetString();
        if (string.IsNullOrWhiteSpace(str))
            return DateTime.MinValue;
        return DateTime.TryParse(str, out var dateTime) 
            ? dateTime 
            : throw new InvalidDataContractException($"Unable to read DateTime from [{str}]");
    }

    [Obsolete("Use ParsePrimitive<T>() instead", true)]
    public static T ParseSimple<T>(this Utf8JsonReader reader)
        => throw new NotImplementedException($"Use ParsePrimitive<T>() instead");
    
    
    /// <summary>
    /// Casts reader.Value to T, where IsSimpleType(typeof(T)) is true
    /// </summary>
    /// <param name="reader"></param>
    /// <typeparam name="T"></typeparam>
    /// <returns>default(T) or string.Empty (if string), if cast fails</returns>
    /// <exception cref="InvalidDataContractException"></exception>
    public static T ParsePrimitive<T>(this Utf8JsonReader reader)
    {
        var typeT = typeof(T);

        if (typeT == typeof(bool))
            return (T)(object)ParseBool(reader);
        if (typeT.GetTypeInfo().IsEnum)
            return reader.ParseEnum<T>();
        if (typeT == typeof(byte))
        {
            if (reader.TryGetByte(out var byteVal) && byteVal is T byteT)
                return byteT;
            return default;
        }
        if (typeT == typeof(string))
        {
            if ((reader.ParseString() ?? string.Empty) is T stringT)
                return stringT;
        }
        if (typeT == typeof(int))
        {
            if (reader.ParseInt() is T intT)
                return intT;
            return default;
        }
        if (typeT == typeof(long))
        {
            if (reader.ParseLong() is T longT)
                return longT;
            return default;
        }
        if (typeT == typeof(double))
        {
            if (reader.ParseDouble() is T doubleT)
                return doubleT;
            return default;
        }
        if (typeT == typeof(DateTime))
        {
            if (reader.ParseDateTime() is T dateTimeT)
                return dateTimeT;
            return default;
        }
        throw new InvalidDataContractException(
            $"Type [{typeT}] is not supported by ReadJsonSimple [{reader.TokenType}]");
    }


    /// <summary>
    /// Read enum (of type T) from Utf8JsonReader
    /// </summary>
    /// <param name="reader"></param>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T ReadEnum<T>(this Utf8JsonReader reader)
    {
        reader.Read();
        return reader.ParseEnum<T>();
    }

    /// <summary>
    /// Casts reader.Value to enum of type(T)
    /// </summary>
    /// <param name="reader"></param>
    /// <typeparam name="T"></typeparam>
    /// <returns>default if cast fails</returns>
    /// <exception cref="Exception"></exception>
    public static T ParseEnum<T>(this Utf8JsonReader reader)
    {
        var result = (T)Enum.ToObject(typeof(T), -1);
        if (reader.TokenType == JsonTokenType.Integer)
            result = (T)Enum.ToObject(typeof(T), reader.Value ?? 0);
        else if (reader.TokenType == JsonTokenType.String)
        {
            try
            {
                var s = ParseString(reader);
                if (string.IsNullOrEmpty(s))
                    result = (T)Enum.ToObject(typeof(T), reader.Value ?? 0);
                else
                    result = (T)Enum.Parse(typeof(T), s);
            }
            catch (Exception ex)
            {
                QLog.Error(ex);
            }
        }
        else
            throw new Exception($"Invalid JSON token type [{reader.TokenType}] for Enum type [{typeof(T)}]");
        return result;
    }
    /*
    public static T ReadIJsonReadable<T>(this Utf8JsonReader reader) where T : IJsonReadable<T>, new()
    {
        reader.Read();
        return reader.ParseIJsonReadable<T>();
    }
    */

    /// <summary>
    /// Casts reader.Value to IJsonReadable T
    /// </summary>
    /// <param name="reader"></param>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T ParseIJsonReadable<T>(this Utf8JsonReader reader) where T : IJsonReadable<T>, new()
    {
        var result = new T();
        result.PropertiesFrom(reader);
        return result;
    }
    #endregion

    
    #region Writing
    /// <summary>
    /// Write PropertyName replacing any characters that are OS and Json unsafe
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    public static void WriteSafePropertyName(this Utf8JsonWriter writer, string name)
        => writer.WritePropertyName(name.ReplaceIllegalCharacters());
    


    private static readonly TypeInfo IJsonWriteableTypeInfo = typeof(IJsonWriteable).GetTypeInfo();
    /// <summary>
    /// Write list to Utf8JsonWriter
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="list"></param>
    /// <param name="justValues"></param>
    /// <typeparam name="T"></typeparam>
    public static void WriteList<T>(this Utf8JsonWriter writer, IEnumerable<T> list, bool justValues = false)
    {
        writer.WriteStartArray();
        foreach (var item in list)
        {
            if (item is IJsonWriteable writeable && IJsonWriteableTypeInfo.IsAssignableFrom(typeof(T).GetTypeInfo()))
                writeable.WriteValue(writer, justValues);
            else
                writer.WriteValue(item);
        }        
        writer.WriteEnd();
    }
    

    // ReSharper disable UnusedParameter.Global
    
    /// <summary>
    /// Write BigInteger Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, BigInteger value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write BigInteger? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, BigInteger? value, bool justValues = false)
    {
        if (!value.HasValue && justValues)
            return;
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write bool Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, bool value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write bool? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, bool? value, bool justValues = false)
    {
        if (!value.HasValue && justValues)
            return;
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write byte Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, byte value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write byte? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, byte? value, bool justValues = false)
    {
        if (!value.HasValue && justValues)
            return;
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write byte[] Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, byte[] value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write char Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, char value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write char? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, char? value, bool justValues = false)
    {
        if (!value.HasValue && justValues)
            return;
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write DateTime Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, DateTime value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write DateTime? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, DateTime? value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write DateTimeOffset Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, DateTimeOffset value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write DateTimeOffset? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, DateTimeOffset? value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write decimal Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, decimal value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write decimal? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, decimal? value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write double Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, double value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write double? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, double? value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write float Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, float value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write float? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, float? value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write Guid Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, Guid value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write Guid? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, Guid? value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write int Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, int value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write int? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, int? value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write long Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, long value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write long? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, long? value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write sbyte Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, sbyte value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write sbyte? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, sbyte? value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write short Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, short value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write short? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, short? value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write string Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, string? value, bool justValues = false)
    {
        if (value is null && justValues)
            return;
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }
    
    /// <summary>
    /// Write TimeSpan Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, TimeSpan value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write TimeSpan? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, TimeSpan? value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write ushort Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, ushort value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write ushort? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, ushort? value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write uint Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, uint value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write uint? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, uint? value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write ulong Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, ulong value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write ulong? Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, ulong? value, bool justValues = false)
    {
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }

    /// <summary>
    /// Write Uri Property key and value
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <param name="justValues"></param>
    public static void WritePvPair(this Utf8JsonWriter writer, string name, Uri? value, bool justValues = false)
    {
        if (value is null && justValues)
            return;
        writer.WriteSafePropertyName(name);
        writer.WriteValue(value);
    }


    public static void WritePvPair(this Utf8JsonWriter writer, string name, IJsonWriteable value, bool justValues = false)
    {
        //if (value == null)
        //    return;

        writer.WriteSafePropertyName(name);
        value.WriteValue(writer, justValues);
    }

    public static void WritePvPair<T>(this Utf8JsonWriter writer, string name, IEnumerable<T> enumerable, bool justValues = false)
    {
        //if (enumerable == null)
        //    return;

        if (enumerable is ICollection<T> { Count: 0 })
            return;
        writer.WriteSafePropertyName(name);
        writer.WriteList(enumerable, justValues);
    }
    
    
    // ReSharper restore UnusedParameter.Global
    #endregion
    
    
}
